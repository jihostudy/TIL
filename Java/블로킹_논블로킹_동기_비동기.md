<a href="https://vivid-chamomile-2f5.notion.site/Lecture7-191d85adc2df8073b435de016b5dffe8" target="_blank">정리 파일 링크</a> 

## 정의

### 블로킹 / 논블로킹

정의

- 현재 작업이 block (차단, 대기) 되느냐 아니냐에 따른 개념
    - 전체적인 작업의 흐름과 관련되어 있다.
- 제어권과 관련된 개념으로, 제어권이 누구에게 있는지로 이해하면 된다.

**제어권**

- 운영체제의 커널(I/O 동작)에서 파생된 단어로, 함수의 코드나 프로세스의 실행 흐름을 제어할 수 있는 권한을 의미한다.
    - 제어권이 넘어가게 되면, 블로킹되게 된다
- 즉, 함수(caller)가 호출한 함수(callee)에게 제어권을 주느냐 안주느냐에 따라 블로킹, 논블로킹으로 구분된다.
    - 블로킹: 함수가 호출한 함수에게 제어권을 넘겨주고, 블록(block)된다.
    - 논 블로킹: 함수가 호출한 함수에게 제어권을 넘겨주지 않고, 논 블록(non-block)되며 자신의 프로세스(스레드)를 계속 실행한다.
    

### 동기 / 비동기

<aside>
💡

동기/비동기 vs 블로킹/논블로킹은 비슷하지만 다른 개념이다.

앞서 블로킹/논블로킹에서 “제어권”을 가지고 이해했다면, 동기/비동기는 프로세스의 실행 순서와 관련해서 이해해보자.

</aside>

정의

- 요청한 작업의 실행 순서를 이전 작업의 완료 여부를 따지는지 안 따지는지와 관련된 개념
    - 동기: 이전 작업의 완료 여부를 따져 순서대로 처리하는 방법
    - 비동기: 이전 작업의 완료 여부를 따지지 않고 요청한 순서대로 처리하는 방법

## 다양한 시나리오 조합

### 블로킹 + 동기

- C / Java 프로그램에서 입력을 받아 프로그램을 실행하는 일반적인 상황이 이에 해당한다.
- 즉, 다른 작업(함수 호출)이 실행되면 제어권을 뺏겨 호출한 함수는 Block되며, 다른 작업의 완료 여부를 받아 순차적으로 실행되는 시나리오.
- 예시
    
    파일 내용을 모두 읽은 후에 다음으로 넘어가는 코드
    
    ```jsx
    const fs = require('fs'); // 파일 시스템 모듈 불러오기
    
    // 동기적으로 파일 읽기
    const data1 = fs.readFileSync('file1.txt', 'utf8'); // file1을 sync으로 read 함
    console.log(data1); // 파일 내용 출력하고 적절한 처리를 진행
    
    const data2 = fs.readFileSync('file2.txt', 'utf8'); 
    console.log(data2); 
    
    const data3 = fs.readFileSync('file3.txt', 'utf8'); 
    console.log(data3);
    ```
    

### 논블로킹 + 비동기

- 브라우저에서 리소스를 다운받는 과정이 이에 해당된다.
    
    ![image.png](attachment:321613de-0560-42e9-947e-a3fad6c7409c:image.png)
    
- 즉, 다른 작업이 시행되는 와중에도 자신의 작업은 수행하며 (Non-Blocking), 다른 작업(함수 호출)은 바로 호출되어 순서가 지켜지지 않는 방식
- 예시
    
    블로킹 + 동기와 다른 점은 `readFileSync` 대신 `readFile`을 실행하여 비동기적으로 처리하고 있으며, 제어권을 넘기지 않아서 마지막 `console.log(’done’)`이 제일먼저 출력되게 된다.
    
    ```jsx
    // 비동기적으로 파일 읽기
    const fs = require('fs'); // 파일 시스템 모듈 불러오기
    
    fs.readFile('file.txt', 'utf8', (err, data) => { // 파일 읽기 요청과 콜백 함수 전달
      if (err) throw err; // 에러 처리
      console.log(data); // 파일 내용 출력
    });
    
    fs.readFile('file2.txt', 'utf8', (err, data) => {
      if (err) throw err; 
      console.log(data);
    });
    
    fs.readFile('file3.txt', 'utf8', (err, data) => { 
      if (err) throw err; 
      console.log(data);
    });
    
    console.log('done'); // 작업 완료 메시지 출력
    ```
    
- 예시
    
    프론트엔드에서 백엔드와 API 통신을 하며  `isLoading`, `isFetching` 을 사용해본 적이 있을 것이다.
    
    이때, 클라이언트는 로딩화면을 보여준다.
    
    로딩화면을 보여주므로, 논블로킹 방식이며  비동기로 데이터를 페칭하는 방법인 것이다.
    

### 논블로킹 + 동기

- 자바에서 스레드를 만들어 작업을 처리하면서, 메인 스레드에서는 계속 스레드 진행상황을 확인하는 방법이 이에 해당된다.
- 즉, 다른 작업(호출된 함수)에게 제어권을 넘기지 않아서, 기존 작업(호출한 함수)은 계속 작업을 수행한다.
    
    이때, 다른 작업(호출된 함수)가 작업을 완료했는지 확인한 이후에, 다음 다른 작업을 수행하는 방법
    
    예시
    
    자바에서 스레드의 진행상황을 메인 스레드에서 지속적으로 감시(확인)하는 방법이 이에 해당한다.
    
    ```java
    // Runnable 인터페이스를 구현하는 클래스 정의
    class MyTask implements Runnable {
        @Override
        public void run() {
            // 비동기로 실행할 작업
            System.out.println("Hello from a thread!");
        }
    }
    
    public class Main {
        public static void main(String[] args) {
            // Thread 객체 생성
            Thread thread = new Thread(new MyTask());
    
            // 스레드 실행
            thread.start();
    
            // Non-Blocking이므로 다른 작업 계속 가능
            System.out.println("Main thread is running...");
    
            // Sync를 위해 스레드의 작업 완료 여부 확인
            while (thread.isAlive()) {
                System.out.println("Waiting for the thread to finish...");
            }
            System.out.println("Thread finished!");
            
            System.out.println("Run the next tasks");
        }
    }
    ```
    
- 예시
    
    자바스크립트에서 `Promise.then` 이 논블로킹 + 비동기 방법이다.
    
    이후, `await` 키워드를 통해 비동기를 동기로 전환하여 실행 순서를 관리할 수 있다.
    

- 예시
    
    게임에서 로딩바를 표시하며 맵을 이동하는 경우를 생각해보자.
    
    메인화면은 주기적으로 로딩바를 업데이트하므로 제어권을 가지고 있으므로, 논블로킹 방식이다.
    
    또한, 끊임없이 데이터의 어느정도 받았는지 확인하므로 동기 방식이다.
    

### 블로킹 + 비동기

- 실질적으로 많이 사용되지 않는 안티 패턴이다.
- 제어권을 호출된 함수에게 넘기며 블록된다 → 블로킹
    
    다른 작업(호출된 함수)들은 실행 순서에 관계 없이 호출된 순서대로 시행된다.
    
- 예시
    
    `node.js`는 비동기 처리를 하며, `MySQL`의 쿼리 작업은 블로킹으로 구현되어 있다.
    
    따라서, `node.js`에서는 `async/await`을 통해 일부러 비동기를 동기로 바꾸어 구현하기도 한다.
    

## 정리 키워드 답변

<aside>
💡

동기 / 비동기

동기: 함수들의 실행 순서가 순차적으로 실행되는 방법.

비동기: 함수들의 실행 순서가 이전 실행 함수의 종료를 기다리지 않고 병렬적으로 실행되는 방법

</aside>

<aside>
💡

블로킹 / 논블로킹

운영체제의 I/O에서 사용하는 제어권과 관련이 많은 개념으로,

블로킹: 제어권을 호출된 함수(callee)에게 넘겨 블록되는 방법

논블로킹: 제어권을 호출된 함수(callee)에게 넘기지 않아 다른 함수와 별개로 호출한 함수(caller)가 실행되는 방법

</aside>

<aside>
💡

동기 / 비동기의 차이를 설명하고 파일 읽기 작업을 예시로 들어 설명해주세요

동기는 함수들이 순차적으로 실행되며, 비동기는 함수들이 실행 순서와 관계없이 병렬적으로 실행될 수 있다.

자바스크립트에서 파일 읽기 방법은 2가지가 존재한다. `readFile`와 `readFileSync` 중 어떤 방식을 사용하느냐에 따라 동기/비동기 방법을 사용할 수 있다.

```jsx
const fs = require('fs');

const 동기 = fs.readFile(파일경로);     
const 비동기 = fs.readFileSync(파일경로); 
```

</aside>

<aside>
💡

블로킹과 논블로킹을 제어권 관점에서 설명해주세요.

우선 제어권은 함수 호출이나 프로세스 실행과 같은 실행 흐름을 제어할 수 있는 권한을 의미합니다.

블로킹: 제어권을 호출된 함수(callee)에게 넘겨 Block되는 것을 의미한다.

논블로킹: 제어권을 넘기지 않고 다른 함수 실행중에 동시에 실행될 수 있는 환경을 의미한다.

</aside>

<aside>
💡

동기 + 블로킹과 동기 + 논블로킹 조합의 차이를 설명해주세요.

동기 + 블로킹은 자바, C를 사용하여 콘솔 입력을 받는 프로그램 같이 코드가 순차적으로 실행되는 특징을 지닌다.

바년, 동기 + 논블로킹은 자바에서 스레드를 이용하면서 스레드의 실행 경과를 지속 측정하는 경우가 이에 해당한다.

Caller는 논블록되어 Callee(생성된 스레드)의 실행 경과를 계속해서 관찰하며, Callee가 종료되는 경우 다른 함수를 실행하는 방법이 이에 해당한다.

</aside>

<aside>
💡

비동기 I/O와 논블로킹 I/O는 같은 개념인가요? 두 개념이 어떻게 다르다고 생각하시나요?

다릅니다.

두 방식은 호출된 함수가 종료되었는지 판단하는 방법의 관점에서 서로 다릅니다.

비동기 I/O는 호출된 함수(Callee)가 종료되면, 콜백 함수와 같은 방식으로 실행 종료를 알리지만,

논블로킹 I/O는 호출한 함수(Caller)가 호출된 함수(Callee)가 종료되었는지 지속적으로 물어보는 (Polling) 방식을 사용해야 합니다.

</aside>

<aside>
💡

(선택) 멀티 스레드 환경에서 블로킹 I/O를 사용할때 발생하는 컨텍스트 스위칭 오버헤드를 줄이기 위한 방법은 어떤것이 있나요?

(스프링 부트)

스프링 부트를 사용하는 방법을 공부했으며, 아직 스프링 부트를 학습하지 않아 대략적으로 공부했습니다.

기존의 Spring MVC 기반의 웹 애플리케이션은 Blocking I/O를 토대로 실행되며, 요청을 처리할때마다 스레드가 생성된다.

따라서, 대량의 요청을 처리하려면 많은 스레드가 생성되며 CPU 대기시간이 늘어나고, 컨텍스트 스위칭이 자주 일어납니다.

→ Non-Blocking I/O 방법으로 전환한다.

Spring WebFlux, Netty를 사용하면 Non-Blocking I/O 방식으로 멀티 스레딩 환경을 구현할 수 있다.

</aside>

<aside>
💡

(선택) 웹 서버 아키텍처에서 논블로킹 방식이 주는 성능적 이점은 어떤것이 있나요?

- 요청을 보내고 **즉시 다음 작업을 처리**할 수 있음.
- I/O가 완료되면 **이벤트가 발생하여 응답을 처리**하기 때문에, **대기 시간이 줄어듦**.
- 스레드 개수를 줄이면서도 **CPU 사용률을 최적화**할 수 있음.
- 필요한 경우에만 I/O 처리를 수행하므로 **메모리 사용량이 절감**됨.
</aside>
