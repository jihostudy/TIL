<a href="https://vivid-chamomile-2f5.notion.site/Lecture6-190d85adc2df802e9542ebb7be84a6f3?pvs=4">정리 사이트</a>

### 스레드와 프로세스

스레드(Thread) :  프로세스 내에서, 실행되는 흐름의 단위

프로세스(Process) : 메모리를 할당받고, 이 할당된 메모리 공간을 가지고 독립적으로 실행되는 것

- 프로세스는 연속적으로 실행되고 있는 컴퓨터 프로그램을 의미한다.
- 프로세스는 각자 독립된 영역(코드, 데이터, 스택 등)을 가지며, 다른 프로세스와 독립적으로 작동한다.
- 스레드는 한 프로세스 내에서 여러 스레드(멀티 스레딩)를 생성할 수 있으며, 스레드간 자원과 메모리를 공유(힙 메모리)한다.
    - 따라서, Race-Condition (경쟁 상태)이 발생할 수 있는 가능성이 있으므로, 이에 대한 대비와 대책이 필요하다
    - 동시성 관리 (Concurrency), 자원 사용 최적화를 위해서 스레드를 사용하는 것이 좋다
    - 멀티스레딩으로 인해 생길수 있는 문제점들
        
        ### **메모리 공간의 독립성 관련 문제 상황**
        
        - 프론트엔드에서는 서버 사이드 렌더링, 백엔드 개발에서는 MSA(마이크로서비스 아키텍쳐)에서 문제가 발생하는 경우가 있다.
            - MSA
                
                독립된 공간에서 동일한 데이터를 다루므로, 데이터의 일관성을 유지하지 못할 수 있다. 따라서, 데이터 일관성을 유지하기 위한 동기화 및 통신 로직이 필요함
                
            - 서버 사이드 렌더링
                
                Node.js 같은 환경에서는 싱글 프로세스에서 여러 요청을 처리한다.
                
                하지만 SSR 과정에서 전역 변수(Global Variable)나 캐시(Cache)가 공유되면한 사용자의 데이터가 다른 사용자에게 영향을 줄 수 있음 (예: 상태 오염).
                
                예시) `userSession` 값은 전역 변수이므로 스레드가 공유하는 데이터 영역에 저장된다.
                
                따라서, 값이 변경되면 모든 스레드가 같은 값을 사용하게 되는데 이는 의도된 결과가 아닐수 있다.
                
                ```jsx
                let userSession = {}; // 서버에서 전역적으로 사용
                
                app.get("/", (req, res) => {
                    userSession[req.ip] = { userId: req.query.user };
                    res.send(`<html><body>Welcome, ${userSession[req.ip].userId}</body></html>`);
                });
                ```
                
                이를 방지하기 위해서는, 각 요청마다 객체를 생성 / 데이터베이스에 `userSession` 저장하는 방법으로 해결할 수 있다.
                
                ```jsx
                // 요청마다 객체 생성
                app.get("/", (req, res) => {
                    let userContext = { userId: req.query.user }; // 요청마다 새로운 객체 생성
                    res.send(`<html><body>Welcome, ${userContext.userId}</body></html>`);
                });
                ```
                
        
        ### **자원 누수 방지 관련 문제 상황**
        
        백엔드 서버가 데이터베이스 연결이나 네트워크 소켓 등을 적절히 관리하지 않으면 자원 누수가 발생할 수  있다.
        
        이러한 누수는 메모리와 CPU 사용률을 지속적으로 증가시켜, 서버의 응답 시간이 길어지고, 극단적인 경우에는 서버 다운으로 이어질 수 있다.
        
        ### **동시성 문제**
        
        동시 접속을 처리할 때 각 요청을 별도의 스레드나 프로세스로 처리하지 않으면, 요청들이 서로 대기 상태에 빠져 시스템의 전반적인 응답 시간이 저하될 수 있습니다. 
        
        또한, 이러한 요청들이 데이터베이스나 파일 시스템과 같은 공유 자원에 접근할 때 적절한 동기화 없이 접근하면 데이터의 무결성 문제가 발생할 수 있습니다.
        

### 프로세스와 스레드를 알아야 하는 이유

- 프로세스를 알아야 하는 이유: “컴퓨터 시스템의 자원 관리, 효율적인 작업 실행, 그리고 운영 체제의 멀티태스킹과 프로그램 동작 원리를 깊게 이해하기 위해서”
- 스레드를 알아야 하는 이유: “동시성과 병렬성을 활용하여 프로그램의 실행 효율을 극대화하고, 자원 사용을 최적화하기 위해서”
- 결국, 웹 애플리케이션의 성능과 동시성 관리, 자원 사용 최적화를 위해

<aside>
💡

인터넷 탭 하나는 프로세스일까? 스레드일까?

프로세스이다.

각 탭은 하나의 프로세스이며, 독립적으로 실행되므로 하나의 탭에서 문제가 생긴다고 해서 다른 탭을 닫을 필요는 없다.

따라서, 프로세스끼리 정보를 교환할 때는 IPC 통신을 통해 데이터를 교환한다.

</aside>

<aside>
💡 동시성 관리 (Concurrency Management) 가 무엇인가요?

여러 계산 과정이나 작업들이 시스템에서 동시에 실행되도록 조정하는 기술 및 과정입니다.

동시성 관리는 다수의 작업이 동시에 실행될 때 발생할 수 있는 충돌을 방지하고, 자원을 효율적으로 활용하도록 돕습니다. 
이는 멀티 스레드 환경에서 특히 중요하며, 프로그램의 성능을 최적화하고 응답성을 향상시키는 데 기여합니다. 
동시성을 관리함으로써 시스템의 스케줄링과 자원 할당이 적절히 이루어져, 동시에 실행되는 작업들 간의 충돌을 최소화할 수 있습니다.

</aside>

<aside>
💡 그럼 프로세스만 많이 사용하면 되는거 아닌가요? 2개 스레드에서 할 일을 2개의 프로세스에서 하면 되잖아요.

스레드 사용의 이유는 **컴퓨터의 메모리**와 같은 자원의 **한계**에 기인합니다. 프로세스 대신 스레드를 활용하면 다음과 같은 이점이 있습니다:

1. **자원 사용 효율성**: 스레드는 프로세스 내 메모리를 공유하기 때문에, 프로세스보다 더 적은 자원을 사용합니다. 이는 메모리의 추가적인 확장 한계를 고려할 때 중요합니다.
2. **통신 용이성**: 같은 프로세스 내 스레드끼리는 메모리를 공유하기 때문에, 데이터 공유가 용이합니다. 이는 복잡한 프로세스 간 통신보다 효율적입니다.
3. **빠른 처리 속도**: 스레드 간 컨텍스트 스위칭은 프로세스 간 전환보다 더 적은 시간과 자원을 소모하므로, 처리 속도가 향상됩니다.

이러한 이유로, 컴퓨터의 메모리 용량과 같은 물리적 한계를 고려할 때 스레드를 사용하는 것이 종종 더 바람직한 선택이 됩니다. 이는 프로그램의 전체 성능을 향상시키고, 자원 사용을 최적화하는 데 기여합니다.

</aside>

<aside>
💡 그럼 반대로 생각하면, 프로세스를 최대한 적게 사용하고 스레드를 최대한 많이 사용하면 좋은거네요?

스레드를 많이 사용하는 것이 효율적일 수 있지만, 모든 상황에서 프로세스를 최소화하고 스레드를 최대화하는 것이 항상 최선의 전략은 아닙니다.

1. **자원 공유의 복잡성**: 스레드들이 메모리와 자원을 공유하므로, 이로 인한 동시성 문제가 발생할 수 있습니다.
여러 스레드가 동일한 데이터에 접근하려 할 때, 데이터의 일관성과 무결성을 유지하기 위한 추가적인 동기화 작업이 필요합니다.
2. **안정성 문제**: 하나의 스레드에서 발생한 문제가 전체 프로세스에 영향을 줄 수 있습니다.
예를 들어, 하나의 스레드에서 예외가 처리되지 않으면 전체 프로세스가 종료될 수 있습니다.
3. **스레드 오버헤드**: 스레드의 수가 너무 많아지면, 스레드 관리를 위한 오버헤드가 증가하고 성능이 저하될 수 있습니다.
스레드 간의 컨텍스트 스위칭 비용도 무시할 수 없는 수준으로 커질 수 있습니다.

따라서, 프로세스와 스레드의 사용은 어플리케이션의 요구 사항, 성능 목표, 그리고 자원의 제한 등 여러 요인을 고려하여 적절한 균형을 찾는 것이 중요합니다.

</aside>

### 프로세스의 메모리영역

- Code
    - 프로그램의 실행 코드나 명령어들이 기계어 형태로 저장되는 영역으로, CPU는 이 영역에 저장된 명령어들을 순차적으로 읽어서 처리합니다.
- Data
    - 코드에서 선언한 전역 변수와 정적 변수가 저장되는 영역으로, 프로그램이 실행되면서 할당되고 종료되면서 소멸된다.
        - 전역 변수 : 프로그램 어디에서나 접근 가능한 변수.
        - 정적 변수 (static variable) :  프로그램의 실행이 시작될 때 생성되고 종료될 때 소멸되는 변수로, 선언된 함수나 파일 내에서만 접근 가능합니다.
            - 자바에서 `static` 키워드를 쓰는 변수, `js`에서는 `es6` 이후 클래스에서 `static`을 사용할 수 있음.
- Stack
    - 함수 안에서 지역변수, 매개변수, 리턴값들이 저장된다. 함수 호출시 기록되고 종료되면 제거된다.
    - 함수의 호출과 관련된 지역 변수, 매개변수, 반환 값 등이 저장되는 영역입니다. 함수가 호출되면 관련 정보가 스택에 쌓이고, 함수가 종료되면 해당 정보는 스택에서 제거됩니다.
- Heap
    - 동적으로 할당되는 데이터를 위한 자유 공간입니다. 프로그래머는 실행 중인 프로그램의 요구에 따라 필요한 만큼의 메모리를 할당하고 해제할 수 있습니다.
        - 예를 들어, 프로그램에서 사용자의 입력에 따라 변할 수 있는 데이터의 양을 관리할 때 주로 힙 영역을 사용합니다.

### 프로세스의 동작 방식

프로세스의 동작 방식은 크게 프로그램의 로딩, 실행, 대기, 종료로 나뉩니다.

1. 로딩 : 프로세스를 메모리에 올리기
2. 실행
3. 대기 : 이벤트 발생과 같은 `Interrupt` 가 발생하여 `ready` 상태로 스케쥴링 메소드에 따라 메모리를 할당받기를 기다리는 단계입니다.
4. 종료 : 할당된 자원을 회수하고 종료됩니다.

### 스레드의 동작 방식

스레드들은 프로세스가 가진 코드, 데이터, 힙 영역을 공유하면서 각각 독립적인 실행 흐름을 가집니다.

→ 각 스레드는 스택 영역을 독립적으로 할당받는다.
