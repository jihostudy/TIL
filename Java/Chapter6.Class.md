## 클래스

객체를 생성하기 위한 템플릿으로, 속성과 메소드를 정의하여 사용한다.

[사용 이유]

- 코드의 직관성
- 재사용성 및 유지보수성

**용어**

- 인스턴스: 클래스를 통해 만들어진 객체
- 필드(멤버): 객체의 데이터 (변수)
- 메소드: 객체의 동적에 해당하는 실행 블록
- 생성자(Constructor): 객체 생성 시 초기화 역할 담당

**[사용 방법]**

1. 인스턴스 선언, 메소드 선언은 다른게 없다.
2. 클래스를 통해 객체를 생성할 때, 초기값을 설정할 수 있는 생성자 함수를 설정할 수 있다.

   - 생성자의 이름은 클래스 이름과 동일 (컴파일러의 인식을 위해)
   - 리턴 타입이 없다
   - 객체가 생성될때 자동으로 한번 호출
   - 매개변수 조건에 따라 여려개의 생성자 함수를 만들 수 있다. → 오버로딩
   - 생성자 함수를 선언하지 않으면, 자동으로 선언된다. 이때, 하나라도 있으면 해당 생성자를 사용해야 한다.
     - 기본 생성자로 사용하면, 인스턴스에 `null`이 저장된다.
   - public 접근 제어자는 파일 이름과 동일한 이름의 클래스 선언에만 붙일 수 있다.
     - 만약, public 접근 제어자가 붙은 2개의 클래스를 정의하면 컴파일 에러가 발생한다.
       - 이는, 자바 컴파일러와 클래스 로더는 **파일 이름과 클래스 이름이 동일**할 것으로 기대하기 때문에, 클래스 로더를 제대로 찾지 못하거나 예외가 발생할 수 있기 때문이다.

   ```java
   public class Dog {
   	String name;

     public Dog(String name) {
       this.name = name;
     }

     public void bark() {
       console.log(`${this.name} says woof`);
     }
   }

   Dog myDog = new Dog("Rex"); // 생성자 함수에 name으로 Rex 전달
   myDog.bark(); // Rex says woof
   ```

기본값 (초기화)

| 자료형      | 초기화값 |
| ----------- | -------- |
| 숫자관련    | 0        |
| 실수        | 0.0      |
| 문자        | '\u0000’ |
| boolean     | false    |
| 참조형 변수 | null     |

### this

객체 자신을 의미하며, 보통 객체의 인스턴스를 가리킬 때 사용된다

- 변수명이 중복되지 않으면 사용하지 않아도 된다.

## 상속

- `extends` 키워드를 통해 상속 받을 수 있다.
- 부모의 인스턴스, 메소드를 사용할 수 있다.
- `super()` 는 부모의 생성자 함수를 사용하는 것이다.
  - 항상 생성자의 처음에 써주어야 함.
  - 사용하지 않을 경우, 부모 클래스의 생성자 함수에 빈 값을 넣어서 호출된다.

### 메소드 오버로딩 vs 오버라이딩

- 오버로딩 (Overloading)
  하나의 클래스 내부에서 메소드를 매개변수의 타입이나 개수를 다르게 하여 여러 번 정의하는 것
  - 오버로딩은 매개 변수의 타입, 개수, 순서로 JVM이 서로 다른 메소드로 인식하기 때문에 다음의 경우는 오버로딩으로 인식하지 않음
    - 매개 변수 이름만 다름
    - 리턴 타입만 다르고 매개 변수가 동일
  - ‼️ 주의: 매개변수가 타입이 동일하지 않음에도 불구하고, 자동 타입 변환이 가능한 경우 해당 함수가 실행된다.
    ```java
    // Class
    int double(int x,int y);
    double double(double x, double y);  // ✅ 실행됨

    // 실행
    int a = 1;
    double b = 2.5;
    Class.double(a,b) // 컴파일 에러가 발생하지 않고, double double(double x, double y); 이 실행됨
    ```
  ```java
  class Animal {
      public String bark() {
          return "bark-bark";
      }

      public String bark(String voice) {
          return voice;
      }
  }
  ```
- 오버라이딩
  자식 클래스에서 부모 클래스의 메소드를 재정의하는 방법
  ```java
  public class Cat extends Animal {
     // #2. 메소드 오버라이팅
      @Override
      public String bark() {
          return "사람은 짖지 않습니다";
      }
  }
  ```

### 인스턴 멤버와 정적 멤버

먼저, 지금까지 공부했던 기본적인 변수, 메소드를 인스턴스 변수 및 메소드라고 한다.

- 인스턴스 멤버: 객체마다 가지고 있는 멤버
- 정적 멤버: 클래스에 위치시키고 객체들이 공유하는 멤버

[인스턴스 멤버와 메소드]

- 객체(인스턴스)를 생성한 후 사용할 수 있는 필드와 메소드를 의미한다.
  - 이때, 인스턴스 메소드는 메소드 영역에 관리된다. → 메소드는 코드 블록이므로 객체마다 동일한 코드 블록을 가지고 있을 필요가 없기 때문이다.
- 인스턴스 필드는 객체 없이는 사용될 수 없다.
- `this`는 인스턴스 멤버인 필드를 명시할 때 사용된다.

[정적 멤버와 메소드]

- 클래스에 고정된 멤버로서 객체를 생성하지 않고 사용할 수 있는 필드와 메소드
  - 객체를 선언해서 사용할 수도 있지만, 메모리 낭비임.
- `static` 키워드를 붙여서 사용한다.
- 클래스 로더가 바이트 코드(클래스)를 로딩해서 메소드 메모리 영역에 적재할 때 클래스별로 관리된다.
- 정적 메소드 내부에서는 인스턴스 필드나 인스턴스 메소드`(this)`를 사용할 수 없다. → 컴파일 에러 발생

  ```java
  public class ClassName {
  	int field1;
  	void method1 {}

  	static void method2 {}
  	static void method3 {
  		this.filed1     // ❌ 불가능
  		this.method1(); // ❌ 불가능
  		method2{};      // ✅
  	}
  }
  ```

- 그렇다면, 인스턴스 멤버와 정적 멤버를 언제 구분해서 사용해야 할까?
  this 키워드를 사용하는 경우, 무조건 인스턴스 멤버(메소드)로 사용해야 한다.

### 싱글톤 패턴

- 프로그램에서 단 하나의 객체만 만들도록 하여 사용하는 경우
- 싱글톤 패턴은 인스턴스를 여러개 만들 필요가 없는 경우, 불필요한 자원 사용을 최소화하고 프로그램이 예상치 못한 결과를 만드는 경우를 방지할 수 있다.
  - 따라서, 객체를 만들 때 전역에서 생성해서 관리하는 방법이다.
- 단, 멀티 스레드 환경에서의 스레드 Safe한 상황을 위한 관리 등, 관리하는 것이 어렵다.

만드는 방법

1. 클래스 외부에서 new 연산자로 생성자를 호출할 수 없도록 막아야 한다.
2. 유일한 단일 객체를 저장할 정적 멤버가 필요하다.
3. 유일한 단일 객체를 반환할 수 있는 정적 메소드가 필요하다.

```java
public class Singleton {
    private static Singleton value;

    private Singleton() {

    }

    public static Singleton getInstance() {
        if(value == null) {
            value = new Singleton();
        }
        return value;
    }
}
```

### final 필드

- 초기값이 저장되면 프로그램 실행 도중에 실행할 수 없는 값
  - 선언 / 생성자 등 방법을 통해 꼭 초기화를 하여야 한다 → 컴파일 에러 발생
- `final` 필드가 상수인가요? `static final` 필드가 상수인가요?
  static final 필드가 상수입니다.
  상수는 객체마다 저장할 필요가 없는 공용성을 띄며, 여러 가지 값으로 초기화(고정 값) 되지 않아도 되므로,
  `static final` 을 “상수” 라고 부르고 사용하는 것이 맞습니다.

### 접근 제어자

public > protected > default > private 순으로 접근 제한이 강화된다.

| 접근제어자  | 클래스 내 | 패키지 내 | 하위 클래스 | 전역 |
| ----------- | --------- | --------- | ----------- | ---- |
| `public`    | O         | O         | O           | O    |
| `protected` | O         | O         | O           | X    |
| `default`   | O         | O         | X           | X    |
| `private`   | O         | X         | X           | X    |

생성자에도 접근 제어자를 붙일 수 있다.

```java
public class ClassName {
	public className () {};
	protected className () {};
	default className () {};
	private className () {};
}
```

| 접근 제어자 | 사용 범위                                                             |
| ----------- | --------------------------------------------------------------------- |
| public      | 모든 패키지에서 아무런 제약 없이 생성자 호출 가능                     |
| protected   | 같은 패키지 내의 클래스에서 생성자 호출 가능                          |
| default     | 다른 패키지에서는 생성자를 호출할 수 없다.                            |
| private     | 오르지 클래스 내부에서만 생성자를 호출할 수 있고 객체를 만들 수 있다. |

- setter를 통해 매개값을 검증해서 유효한 값만 객체의 필드로 저장하는 방법이 있다.
- getter를 통해 필드값을 가공한 후 외부로 전달하는 방법이 있다.
