## JWT

JWT는 JSON Web Token의 줄임말로, 애플리케이션 간의 정보 교환을 위해 설계된, 정보를 JSON 형식으로 포함하는 자체 포함형(compact and self-contained) 토큰

<aside>
💡

**자체 포함형(compact and self-contained) 토큰**이란?

JWT (JSON Web Token)가 모든 필요한 정보를 자체적으로 담고 있다는 의미를 나타낸다.

이 구조는 JWT가 독립적으로 동작할 수 있도록 해주며, 별도의 추가 데이터베이스 조회 없이도 인증이나 사용자의 권한을 확인할 수 있게 합니다.

</aside>

## 구성 요소

### 1. 헤더 (Header)

헤더는 주로 토큰의 유형(**`typ`**)과 사용된 서명 알고리즘(**`alg`**)을 정의합니다.

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

`typ` : 토큰의 유형

`alg` : HMAC SHA256 알고리즘을 사용하여 토큰이 서명되었음을 명시한다.

> SHA256은 “Secure Hash Algorithm 256-bit”의 약자로, 해시 함수입니다. 
임의의 데이터를 입력받아 256비트 길이의 고정된 크기의 해시 값을 출력합니다. 일방향 해시 함수로서, 해시 값으로부터 원본 데이터를 복구하는 것은 사실상 불가능합니다.
> 

### 2. 페이로드 (Payload)

페이로드는 토큰에 담길 정보, 즉 클레임(claims)을 포함합니다.

클레임은 토큰 사용자에 관한 정보나 추가 메타데이터를 담을 수 있습니다.

예시

```json
{
  "email": "void@startupcode.kr",
  "username": "void",
  "iat": 1609239023,
  "exp": 1609242623
}
```

- `id`와 `username`은 사용자의 식별 정보입니다.
- **`iat`** (Issued At)는 토큰이 발행된 시간으로, 여기서는 유닉스 타임스탬프 형식으로 표현됩니다.
- **`exp`** (Expiration Time)는 토큰의 만료 시간으로, 이 역시 유닉스 타임스탬프로 표현됩니다.
- 참고: `iat`와 `exp`를 사용하는 이유
    
    <aside>
    👨‍💻
    
    ### **`iat` (Issued At)**
    
    - **목적**: 이 클레임은 JWT가 생성되어 발급된 정확한 시간을 나타냅니다.
    - **형식**: **`iat`** 값은 유닉스 타임스탬프(Unix Timestamp)로 표현되며, 이는 1970년 1월 1일 자정(UTC) 이후로 경과된 초(second)의 총량입니다.
    - **사용 이유**: **`iat`** 클레임은 토큰이 언제 발급되었는지를 추적하는 데 유용합니다. 예를 들어, 시스템은 **`iat`** 값을 사용하여 토큰이 발급된 후 예상치 못한 시간이 경과했는지 판단할 수 있으며, 토큰의 신선도를 평가하는 데 사용할 수 있습니다.
    - **보안 측면**: 토큰이 발급된 시간을 알면, 예상치 못한 지연(delay)이나 시간 조작(time manipulation) 시도를 탐지할 수 있습니다.
    
    ### **`exp` (Expiration Time)**
    
    - **목적**: 이 클레임은 JWT의 유효기간을 정의합니다. 즉, 토큰이 만료되는 시점을 명시합니다.
    - **형식**: **`exp`** 값 역시 유닉스 타임스탬프로 표현되어, 토큰이 만료되는 시점의 날짜와 시간을 초 단위로 나타냅니다.
    - **사용 이유**: **`exp`** 클레임은 토큰이 더 이상 유효하지 않게 되는 시점을 설정함으로써, 오래된 혹은 위험에 노출된 토큰이 계속해서 사용되는 것을 방지합니다. 이는 보안 수준을 유지하는 데 필수적입니다.
    - **보안 측면**: 만료 시간을 설정함으로써, 토큰의 재사용(reuse)을 방지하고, 토큰이 탈취되었을 경우 탈취자가 무한정 토큰을 사용하는 것을 제한할 수 있습니다.
    </aside>
    

### 3. 서명 (Signature)

- 서명은 1️⃣ 헤더와 페이로드를 합친 뒤, 2️⃣ 지정된 알고리즘(HS256)으로 해시하고, 3️⃣ 비밀키를 사용하여 서명한 결과입니다.
- 토큰이 변조되지 않았음을 검증하는 데 사용되며, 수신자는 같은 비밀키와 알고리즘을 사용하여 헤더와 페이로드를 해시하고, 이를 서명과 비교함으로써 토큰의 유효성을 검증할 수 있습니다.

<aside>
💡

토큰의 위변조 판단 여부를 아는 방법

서명값을 통해 판단하며, 서명값은 비밀키를 이용하여 헤더와 페이로드 값 전체를 비교하는 역할을 합니다. 

서명값이 직접 변조하여 토큰을 공격자가 만드는 경우, 서버가 계산한 서명과 당연히 다를 것입니다.

또한, (서명값 수정x) 페이로드 값을 수정하는 경우에도, 해시 함수의 특성상 입력값이 변경되는 경우 서명값이 바뀝니다.

따라서, 서버가 변조된 헤더 + 페이로드를 해시, 암호화 해보면 변조되지 않은 서명값과 달라서 변조 되었음을 판단할 수 있습니다.

</aside>

### JWT를 사용하는 이유

- 무상태 인증 (Stateless Authentication)
    
    JWT 자체에 사용자 인증 정보와 데이터를 포함하고 있어서 서버가 세션 상태를 유지할 필요가 없습니다.
    
- 서버 간의 부담 감소 및 안정적인 확장성
    
    JWT가 사용자 인증 정보를 포함하고 있어 부하 분산이 쉬워지고, 서버 간의 동기화가 필요없습니다. 따라서, 서버를 확장하는데에도 걸림돌이 되지 않습니다.
    
- [보안과 데이터 무결성 보장](https://www.notion.so/199d85adc2df809db58df76c96f7e8ee?pvs=21) *(블록 링크 참고)*
- 유연성과 다양한 적용 가능성

위에서, 세션 상태를 저장할 필요가 없는 것이 JWT를 사용하는 이유 중 하나로 언급했습니다.

그렇다면, 세션 기반 인증과 JWT 인증 방식의 차이점에는 무엇이 있을까요?

| **구분** | **장점** | **단점** |
| --- | --- | --- |
| **세션 기반 인증** | **상태 유지**: 서버 메모리 또는 DB에 로그인 상태 저장

**보안성**: 세션 ID는 사용자 정보를 포함하지 않음, 서버에서만 세션 데이터 관리 | **스케일링 문제**: 사용자 정보 서버 저장, 대규모 시스템에서 복잡함

**로드 밸런서 구성해야할 상황**: 세션 정보 공유의 어려움 |
| **JWT 기반 인증** | **스케일러빌리티**: 정보 내장, 서버 상태 유지 필요 없음, 부하 감소 

**확장성과 유연성**: 서비스 간 쉬운 토큰 전달 | **보안 문제**: 토큰 탈취 시 사용자 행동 가능
**토큰 크기**: 세션 ID보다 크며 네트워크 오버헤드 증가
**상태 유지 문제**: 서버에서 토큰을 강제로 만료시킬 방법이 없어 로그아웃이나 토큰 만료 처리 복잡 |

*경우에 따라서 JWT와 세션을 혼합하여 사용하기도 합니다.*

*또한, 단기 JWT + 장기 세션방식으로 로그인 세션과 관련된 주요 정보는 서버의 세션에 저장하고, JWT는 단기간 유효한 토큰으로 발급하여 API 요청에 사용하기도 합니다.*

→ 보안 사고 위험성을 줄일 수 있다.

보통, 초기 로그인에 지급받는 Access Token과 Access Token의 유효 기간이 만료된 경우 새로운 토큰을 발급받기 위한 Refresh Token 2가지를 동시에 사용합니다.

### JWT의 탈취 취약점 및 해결책

JWT는 Base64로 인코딩되어 전송하기 때문에, 탈취되었을때 중요한 정보가 포함되면 안됩니다.

따라서, 다음과 같은 해결책에 대응합니다.

1. HttpOnly 쿠키 사용
    
    클라이언트가 토큰에 접근하지 못하도록 하여 XSS 공격 방지
    
2. 토큰 블랙리스트 기능
    
    탈취된 토큰을 무효화하는 방법이나, 그러려면 서버에서 토큰 정보를 저장해야 해서 세션과 비슷한 구현 방식이 됩니다.
    
3. 짧은 유효기간 설정
    
    AT의 유효기간을 짧게 설정하고, 필요한 경우 재발급 받도록 한다.
    
4. 리프레시 토큰 회전
    
    RT을 사용하여 AT를 재발급 받으면, 새로운 RT로 교체하고 이전 토큰은 즉시 무효화합니다.
    

### JWT의 동시접속 제한 문제

JWT 자체로는 동시 접속을 제한할 수 없다. 동시 접속을 제한하려면 사용자의 세션을 서버에서 관리하여야 하기 때문입니다.

따라서, 이에 대한 대응책으로 RT를 통해 사용자의 세션을 서버에서 관리하여 동시 접속을 제한합니다.

- 구체적인 방법 (재밌으니까 한번 보기)
    
    ### ✅ **세션 정보를 RT(Refresh Token)로 제한하는 방법**
    
    RT(Refresh Token)를 활용하면 **동시 접속을 제한할 수 있는 구조를 만들 수 있어**.
    
    즉, **RT를 세션 관리 도구로 활용하는 방식**이야.
    
    ### 🔹 **1. 일반적인 JWT 인증 흐름**
    
    1. 사용자가 로그인하면 **서버가 JWT(AT, Access Token) + RT(Refresh Token)를 발급**
    2. 클라이언트는 요청할 때 **JWT(AT)를 헤더에 담아 서버로 전송**
    3. 서버는 **JWT의 유효성을 검사한 후 요청을 처리**
    4. JWT가 만료되면 클라이언트는 **RT를 이용해 새로운 JWT를 요청**
    
    🚨 **이 구조에서는 서버가 사용자의 로그인 상태를 직접 관리하지 않음** → 즉, 동시 접속을 막을 방법이 없음.
    
    ---
    
    ### 🔹 **2. RT를 통한 세션 관리 방식 (동시 접속 제한)**
    
    RT를 활용하여 **서버에서 세션을 관리하고, 이를 기반으로 동시 접속을 제한**할 수 있어.
    
    구체적인 방법은 다음과 같아.
    
    1️⃣ **로그인할 때 RT를 서버 DB에 저장**
    
    - 사용자가 로그인하면 서버는 **RT를 발급**하고 이를 DB(또는 Redis 같은 저장소)에 저장
    - 이때, **사용자마다 1개의 RT만 유지**하도록 설계
    - 예) `user_id=123` → `RT=xyz789`
    
    2️⃣ **기존 RT를 대체하는 방식으로 새로운 로그인 관리**
    
    - 사용자가 다른 기기에서 로그인하면 **새로운 RT가 발급됨**
    - 서버는 **기존 RT를 무효화하고 새로운 RT만 유지**
    - 즉, **동시에 여러 개의 RT를 유지할 수 없도록 설계**
    
    3️⃣ **JWT 갱신 시, RT 검증을 통해 동시 접속을 차단**
    
    - 사용자가 JWT(AT)가 만료될 때, RT를 이용해 새로운 AT를 요청
    - 서버는 **DB에 저장된 RT와 요청한 RT를 비교**
    - **이미 다른 기기에서 로그인하여 RT가 변경되었다면, 요청을 거부**
    - 즉, **가장 최근 로그인한 기기에서만 인증이 가능**

<aside>
💡

### 실무에서는 어떻게 JWT를 사용할까?

1. **쿠키와 함께 사용하기 (JWT + HttpOnly 쿠키)**:
    - JWT를 쿠키에 저장하되, **HttpOnly** 속성을 설정하여 클라이언트 측 JavaScript에서 접근할 수 없도록 합니다. 이는 XSS 공격으로 인한 토큰 탈취를 방지하는 데 도움이 됩니다.
    - **Secure** 옵션을 사용해 HTTPS를 통해서만 쿠키가 전송되도록 설정하여 보안을 강화할 수 있습니다.
2. **세션과 혼합 사용하기 (JWT + 세션 스토리지)**:
    - JWT를 발급하되, 세션 ID를 함께 사용하여 서버 측에서 세션 관리와 함께 JWT를 사용합니다. 이를 통해 JWT의 무효화 문제를 해결할 수 있습니다.
    - 로그아웃 시 세션을 무효화하고, 서버에서 해당 세션 ID에 연결된 JWT를 무효화할 수 있습니다.
3. **토큰 블랙리스트 또는 화이트리스트 사용**:
    - 서버 측에 블랙리스트를 유지하여 특정 JWT를 무효화할 수 있습니다. 예를 들어, 로그아웃 시 사용된 JWT의 식별자를 블랙리스트에 추가하여 해당 JWT가 더 이상 사용되지 않도록 합니다.
    - 반대로, 화이트리스트를 사용하여 유효한 JWT만을 서버에서 관리하고, 만료된 JWT는 자동으로 제거될 수 있도록 합니다.
4. **Refresh Token 사용**:
    - 만료 시간이 짧은 Access Token과 만료 시간이 긴 Refresh Token을 함께 사용합니다.
    - Access Token이 만료되면, Refresh Token을 통해 새로운 Access Token을 발급받을 수 있습니다. 이 방법은 사용자가 지속적으로 로그인 상태를 유지하면서 보안을 강화할 수 있게 해줍니다.
    - Refresh Token은 서버 측에서 관리하거나, Secure, HttpOnly 쿠키에 저장하여 관리할 수 있습니다.
5. **IP 주소 및 User-Agent 기반 토큰 관리**:
    - JWT를 사용할 때, 추가적인 보안 측정으로 토큰이 발급된 IP 주소와 User-Agent 정보를 저장하고, 동일한 정보로 요청이 들어올 때만 유효성을 인정하는 방법입니다.
    - 이를 통해 토큰이 탈취되더라도 다른 환경에서 사용되는 것을 방지할 수 있습니다.
</aside>
